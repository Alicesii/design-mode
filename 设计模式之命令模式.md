
---
title: 设计模式之命令模式
comments: true
date: 2018-06-02 14:42:11
categories: 博客列表
tags: 设计模式
img:

---

>命令模式

1.1定义：将一个请求封装为一个对象，从而使你可用不同的请求对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

1.2结构图

![ ](http://images.cnblogs.com/cnblogs_com/cliy-10/1212441/o_12.png)
图12

* Command：为所有命令声明了一个接口，调用命令对象的execute()方法就可以让家守着进行相关的动作。

* ConcreteCommand：命令接口实现对象，定义了动作和接受者之间的绑定关系，是“虚”的实现；通常会持有接收者，并调用接收者的功能来完成命令要执行的操作。

* Receiver：接收者，真正执行命令的对象。任何类都可能成为一个接收者，只要它能够实现命令要求实现的相应功能。
* Invoker：要求命令对象执行请求，通常会持有命令对象，可以持有很多的命令对象。这个是客户端真正触发命令并要求命令执行相应操作的地方，也就是说相当于使用命令对象的入口。
* Client：创建具体的命令对象，并且设置命令对象的接收者。注意这个不是我们常规意义上的客户端，而是在组装命令对象和接收者，或许，把这个Client称为装配者会更好理解，因为真正使用命令的客户端是从Invoker来触发执行。

①　在软件系统中，行为请求者与行为实现者之间通常呈现一种紧耦合的关系，但在某些场合，比如要对行为进行记录、撤销、重做事务等处理，这种无法抵御变化的紧耦合是不合适的。

②　从类关系图可以简单地看出：命令模式其实是把需求（Invoker）和具体实现类（Receiver）通过命令层（Command）进行解耦合。

③　在命令模式中，会定义一个命令的接口，用来约束所有的Command对象，然后提供具体的命令实现，每个ConcreteCommand对象是对客户端某个请求的封装。

④　在命令模式中，命令对象并不知道如何处理命令，会有相应的Reveiver对象来真正执行命令。

⑤　在命令模式中，命令对象和接收者对象的关系，并不是与生俱来的，需要有一个装配的过程，命令模式中的Client对象就来实现这样的功能。

⑥　命令模式还会提供一个Invoker对象来持有命令对象，用户就可以通过Invoker来触发并要求执行相应的命令了。

1.1适用场景

* 抽象出待执行的动作以参数化某对象
* 在不同的时刻指定、排列和执行请求
* 支持取消操作
* 支持修改日志，这样当系统崩溃时，这些修改可以被重做一遍
* 用构建在原语操作上的高层操作构造一个系统

1.4优缺点

* 它能比较容易地设计一个命令队列；
* 在需要的情况下，可以较容易地将命令记入日志；
* 允许接收请求地一方决定是否要否决请求；
* 可以容易地实现对请求地撤销和重做；
* 由于加进新地具体命令类不影响其他的类，因此增加新的具体命令类很容易；
* 把请求一个操作的对象与知道怎么执行一个操作的对象分隔开；
* （缺点）可能会导致系统具有过多的具体命令类。

1.5实例

说明：

* 当我们按下启动按钮，电源开始向主板和其它设备供电，主板的系统BIOS（基本输入输出系统）开始加电后自检，主板的BIOS会依次去寻找显卡等其它设备的BIOS，并让它们自检或者初始化，开始检测CPU、内存、硬盘、光驱、串口、并口、软驱、即插即用设备等等，BIOS更新ESCD（扩展系统配置数据），ESCD是BIOS和操作系统交换硬件配置数据的一种手段，等前面的事情都完成后，BIOS才按照用户的配置进行系统引导，进入操作系统里面，等到操作系统装载并初始化完毕，就出现我们熟悉的系统登录界面了。 

* 在命令模式中，会定义一个命令的接口，用来约束所有的Command对象，然后提供具体的命令实现，每个ConcreteCommand对象是对客户端某个请求的封装，对应于机箱上的按钮，一个机箱上可以有很多按钮，也就相当于会有多个具体的命令实现对象。
* 在命令模式中，命令对象并不知道如何处理命令，会有相应的Reveiver对象来真正执行命令。就像电脑的例子，机箱上的按钮并不知道如何处理功能，而是把这个请求转发给主板，由主板来执行真正的功能，这个主板就相当于命令模式的接收者。
*  在命令模式中，命令对象和接收者对象的关系，并不是与生俱来的，需要有一个装配的过程，命令模式中的Client对象就来实现这样的功能。这就相当于在电脑的例子中，有了机箱上的按钮，也有了主板，还需要有一个连接线把这个按钮连接到主板上才行。 * 命令模式还会提供一个Invoker对象来持有命令对象，就像电脑的例子，机箱上会有多个按钮，这个机箱就相当于命令模式的Invoker对象。用户就可以通过Invoker来触发并要求执行相应的命令了，这也相当于真正的客户是按下机箱上的按钮来操作电脑一样。
* 机箱上的按钮就相当于是命令对象，机箱相当于是Invoker，主板相当于接收者对象。命令对象持有一个接收者对象，就相当于是给机箱的按钮连上了一根连接线，当机箱上的按钮被按下的时候，机箱就把这个命令通过连接线发送出去。主板类才是真正实现开机功能的地方，是真正执行命令的地方，也就是“接收者”。
* 命令的实现对象，其实是个“虚”的实现，就如同那根连接线，它哪知道如何实现啊，还不就是把命令传递给连接线连到的主板。把客户的开机请求封装成为一个OpenCommand对象，客户的开机操作就变成了执行OpenCommand对象的方法了？如果还有其它的命令对象，比如让机器重启的ResetCommand对象；那么客户按下按钮的动作，就可以用这不同的命令对象去匹配，也就是对客户进行参数化。

1.5.1.2008A
  已知某企业欲开发一家用电器遥控系统，即用户使用一个遥控器即可控制某些家用电器的开与关。遥控器如左下所示。该遥控器共有4个按钮，编号分别是0至1，按钮0和2能够遥控打开电器1和电器2，按钮1和1则能遥控关闭电器1和电器2。由于遥控系统需要支持形式多样的电器，因此，该系统的设计要求具有较高的扩展性。现假设需要控制客厅电视和卧室电灯，对该遥控系统进行设计所得类图如图11所示。

![ ](http://images.cnblogs.com/cnblogs_com/cliy-10/1212441/o_11.png)
图11

在图11中，类RomoteController的方法onPressButton(int button)表示当遥控器按键按下时调用的方法，参数为按键的编号；Command接口中on和off方法分别用于控制电器的开与关；Light中turnLight(int degree)方法用于调整电灯灯光的强弱，参数 degree值为0时表示关灯，值为100时表示开灯并且将灯光亮度调整到最大；TV中 setChannel(int channel)方法表示设置电视播放的频道，参数channel值为0时表示关闭电视，为1时表示开机并将频道切换为第1频道。

```javascript
class Light{  //电灯类
public:
    void trunLight(int degree){//调整灯光亮度，0表示关灯，100表示亮度最大)；
};
class TV{//电视机类
public:
vold setChannel(int channel]{//调整电视频道，0表示关机，1表示开机并切换到1频道}；
};
class Command{//抽象命令类
public:
    virtual void on()=0;
    virtual void off()=0;
};
class RemoteController{  //遥控器类
protected:
    Command* commands [4];//遥控器有4个按钮，按照编号分别对应4个Command对象
public：
    void onPressButton(int button){  //按钮被按下时执行命令对象中的命令
        if(button % 2==0)commands[button]-＞on();
        else commands[button]-＞off();
    }
    void setCommand(int button，Command* command){
           commands[button]  =command;//设置每个按钮对应的命令对象
}
};
class LightCommand：public Command{  //电灯命令类
protected：Light* light;  //指向要控制的电灯对象
public：
    void On(){light-＞trunLight(100););
    void off()[light-＞  trunLight(0););
    LightCommand(Light * light){this-＞light=light;);
};
class TVCommand：public Command{//电视机命令类
protected: TV*tv;  //指向要控制的电视机对象
public:
    void on(){tv-＞ setChannel(1);};
    void off(){tv-＞setChannel(0););
    TVCommand(TV *tv){this-＞tv=tv;);
};
void main(){
    Light light;TV tv;//创建电灯和电视对象
    LightCommand lightCommand (&light);
    TVCommand tVCommand(&tv);
    RemoteController remoteController;
    remoteController. setCommand(0，&lightCommand);//设置按钮0的命令对象
}
```

1.5.2.2014B
  某灯具厂商欲生产一个灯具遥控器，该遥控器具有7个可编程的插槽，每个插槽都有开关按钮，对应着一个不同的灯。利用该遥控器能够统一控制房间中该厂商所有品牌灯具的开关，现采用Command（命令）模式实现该遥控器的软件部分。Command模式的类图如图14所示。
  
![ ](http://images.cnblogs.com/cnblogs_com/cliy-10/1212441/o_14.png)
图14

```javascript
class Light {
public:
  Light(string name) { /* 代码省略 */ }
  void on() { /* 代码省略 */ }    // 开灯
  void off() { /* 代码省略 */ }  // 关灯
};
class Command {
public:
 virtual void execute(){}; 
}；
class LightOnCommand:public Command { // 开灯命令
private:
  Light* light;
public:
  LightOnCommand(Light* light) { this->light=light; }
  void execute() {light->on(); }
};
class LightOffCommand:public Command { // 关灯命令
private:
  Light *light;
public:
  LightOffCommand(Light* light) { this->light=light; }
  void execute() {loght->off()  ; }
};
class RemoteControl{ // 遥控器
private:
  Command* onCommands[7];
  Command* offCommands[7];
public:
  RemoteControl() { /* 代码省略 */ }
  void setCommand(int slot, Command* onCommand, Command* offCommand) {
    onCommands[slot]=onCommand; 
    offCommands[slot]=offCommand;
  }
  void onButtonWasPushed(int slot) { onCommands[slot]->execute()   ; }
  void offButtonWasPushed(int slot) { offCommands[slot]->execute() ; }
};
int main() {
  RemoteControl* remoteControl=new RemoteControl();
  Light* livingRoomLight=new Light("Living Room");
  Light* kitchenLight=new Light("kitchen");
  LightOnCommand* livingRoomLightOn=new LightOnCommand(livingRoomLight);
  LightOffCommand* livingRoomLightOff=newLightOffCommand(livingRoomLight);
  LightOnCommand* kitchenLightOn=new LightOnCommand(kitchenLight);
  LightOffCommand* kitchenLightOff=new LightOffCommand(kitchenLight);
  remoteControl->setCommand(0, livingRoomLightOn, livingRoomLightOff);
  remoteControl->setCommand(1, kitchenLightOn, kitchenLightOff);
  remoteControl->onButtonWasPushed(0);
  remoteControl->offButtonWasPushed(0);
  remoteControl->onButtonWasPushed(1);
  remoteControl->offButtonWasPushed(1);
  /* 其余代码省略 */
  return 0;
}
```